---
title: "read slopes"
author: "Jens Joschinski"
date: "March 15, 2018"
output: 
  md_document:
  variant: markdown_github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache=TRUE)
library(tidyverse)
library(textreadr)
library(drc)
library(sandwich)
library(lmtest)
```


# General description  
## Aim  
The aim of this project is to correlate climate variability with variability in seasonal timing. Is the slope in seasonal responses a bet-hedging trait, i.e., is it adaptive to spread one's timing in more variable conditions?  


### Overview  
I searched in the web of Science database for studies that measure photoperiodic response curves of invertebrates (folder 02studies/00raw) and extracted the x- and y-coordinates of the points within these curves (folder 02studies/01extracted_data). After adding metadata (latitudes, longitudes,sample sizes, "extracted.xlsx"") I copied a subset of the data into a csv file. The script now calculates the slope and other parameters of the photopeirodic response curve. It uses dose-response curves analysis with package "drc".  

### Specific description  

The data was generated with R version `r getRversion()`. Slope estimates derived with package drc, `r citation('drc')`.

The script fits dose-response curves for all populations, seperately for each study. DRCs can estimate the upper and lower limit (range of diapause responses, usually from 0-100%), the inflection point (critical day length, where 50% of the population are in diapause), and the slope of the curve. I am mostly interested in slope of the curve, but also want to extract the critical day length. But the upper and lower limit have to be estimated as well. From a glimpse at the data it can be seen that the upper and lower limit are not always 0 and 100%, and there are several ways to fit the model. 

Intuitively one would expect that all populations of one species (and hence also all pops that have been sampled in a study) have the same lower and upper limit. One could therefore estimate a global upper and lower limit, and then slope and inflection point for each population (requires 2 degrees of freedom + 2 df per population). As alternative one could however also imagine a conservative bet-hedging strategy, in which a population never reaches 0% diapause to ensure survival in variable climates. In this case, the lower limit varies by populations, while the upper is fixed (requires 1 df + 3 df per population). The opposite situation, in which populationsut vary in their upper limit while the lower limit is fixed (1df + 3 per pop), is counterintuitive, as it is essentially the opposite of conservative bet-hedging. This strategy could mean that some offspring never diapause, even under winter conditions, hoping that a harsh winter climate never arrives (see skewed distribution in halkett 2004, amnat). The last possible version is that both upper and lower limit vary by population. This makes four models (sorted by plausibility): 

1. upper and lower parameter fixed at study mean (requires 2 df plus 2 df per population)
2. upper parameter fixed (requires 1 df plus 3 per population)
3. lower parameter fixed (requires 1df plus 3 per population)
4. both limits vary (requires 4 df per population)

This script first determines the available df to see if options 2-4 are available. Then it fits all models that are allowed, and compares by AIC which one is best. If there are ties (delta AIC <2), the most plausible model (sorted as above) is used. 


### Script  

This script should not be executed completely, becaues it will cause some convergence failure. Also, all models need to be examined by hand (summary may show that some values are actually NA because errors occured without warning). It is rather a description of the methods than an actual executable script.

#### function to decide between models  
This function works on a subset of the data, that has one study with all its popultaions.


```{r choosefun}
choosemodel<-function(input){
  aics <- c(NA,NA,NA,NA) #will store AIcs of up to four possible models 
  #idea: 
  #if df = enough for model 1 {
    #do model 1
    #if df = also enough for model2/3 {
      #do model 2
      #do model 3
      # if df = also enough for model 4{
        #do model 4
    #}}}
  #compare AIC of all recorded models
  
  #is model 1 possible? (2 df + 2 per pop)
  estimates <- nrow(input)
  pops<-unique(input$pops_with_Dia)
  if (length(unique(input$pops_with_Dia))>1){print(paste("something went wrong in study ",ipnut$study[1],"\n"))}
  res_df <- estimates - (2 + 2*pops)

  if (res_df>3){ #keep all aics NA if res_df are insufficient even for simplest model
    drm1<- drm((number/n2)~dl2, curveid=line.ID, data=input, fct=LL.4(), type="binomial", upperl=c(NA,NA,1,NA), lowerl=c(NA,0,NA,NA), weights=n2,  pmodels=data.frame(line.ID,1,1,line.ID)) 
    #this model calculates dose response curve, weighing each point by its sample size (if the information was given) and constraining the range between 0 and 1. Upper and lower limit are estimated by global mean, slope and inflection point by population. 
    aics[1]<-AIC(drm1)
    
    
    #are model 2 and 3 also possible?
    #only runs if first model was calculated, because it takes even more dfs
    res_df<-estimates - (1+ 3* pops)
    if (res_df >3){
       drm2<-drm((number/n2)~dl2, curveid=line.ID, data=input, fct=LL.4(), type="binomial", upperl=c(NA,NA,1,NA), lowerl=c(NA,0,NA,NA), weights=n2, pmodels=data.frame(line.ID,line.ID,1,line.ID))        # upper limit is fixed, but lower limit varies among pops
       aics[2]<-AIC(drm2)
       
       drm3<-drm((number/n2)~dl2, curveid=line.ID, data=input, fct=LL.4(), type="binomial", upperl=c(NA,NA,1,NA), lowerl=c(NA,0,NA,NA), weights=n2, pmodels=data.frame(line.ID,1,line.ID,line.ID))
       #lower limit is fixed, but upper limit varies among pops
       aics[3] <- AIC(drm3)
       
       
       #is model 4 possible?
       #only runs if first three models were calculated
       res_df <- estimates - (4*pops)
       if (res_df>3){
          drm4<-drm((number/n2)~dl2, curveid=line.ID, data=input, fct=LL.4(), type="binomial", upperl=c(NA,NA,1,NA),lowerl=c(NA,0,NA,NA), weights=n2)
          aics[4]<-AIC(drm4)
       }#end model 4
    }#end model 2,3
  }#end model 1
  
  if(sum(is.na(aics))<4){
    diff <- aics[1] - aics
    if(max(diff,na.rm=T)<2){
      final<-drm1
      choice = 1
    } else{
      diff<-data.frame(diff,c(1:4))
      names(diff)<-c("delta","model")
      diff<-diff[order(diff$delta,decreasing = T),]
      if (diff[1,1]-diff[diff$model==2,"delta"]<2){
        final <- drm2
        choice = 2
      } else if (diff[1,1]-diff[diff$model ==3,"delta"]<2){
        final<-drm3
        choice = 3
      } else {
        final<-drm4
        choice = 4
      }
    }
  } else{
      final <-NA
      choice = NA
  }
  return(list(final,choice))
}
```

load data
```{r}
data<-read.table("02studies/01extracted_data/forslopes.csv", header=T,sep="\t")
data<-data[data$cdl=="x",]
data<-separate(data,col=1, into = c("study","pop"), sep ="-",remove=FALSE)
length(unique(data$study)) #52 studies that can be used for CDL calculation
length(unique(data$line.ID)) #353 populations
length(unique(data$study[data$slope=="x"])) # 30 studies can be used for slope calculation
length(unique(data$line.ID[data$slope=="x"]))#170 populations

r<-data.frame(NA,NA,NA,NA,NA,NA,NA,NA,NA)
names(r)<-c("name","b","b_rel","c","c_rel","d","d_rel","e","e_rel") #the results will be stored in a file with these columns
```


```{r}
data<-data[!data$species=="subauraria",]
#notes
#i=1->model3
#2->3
#3->3
#4->4, with aicdiff to model 3 of 2.03
#5->conv failed with drm1 and drm2 (lower limits <0), could only be fixed by removing both box constraints and resulted in several NA in coef estimates; mod3 worked well and was reasonable
#6 has wrong pops with dia (should be 4, not 7). corrected. models 1-3 have missing data in coef, #only way to rectify is removing population UW, then only possible model is drm1. works though. 
#7->3,4,1 in this order. But only because missing value causes strange estimate of upper boundary. Used drm1 anyway.
for (i in 1:length(unique(data$study))){
  sub<-data[data$study==unique(data$study)[i],] #calculate dose response curves for each study   seperately
  sub<-droplevels(sub)
  sub$n2<-round(sub$n2)
  #sub$perc[sub$perc<0]<-0
  #sub$perc[sub$perc>100]<-100
  sub$number<-round(sub$n2 * sub$perc/100)
  sub$number[sub$number>sub$n2]<-sub$n2[sub$number>sub$n2]
  sub$number[sub$number<0]<-0
  
  results<-choosemodel(sub)
  final<-results[[1]]
  

      
  #possible values of "choice" and their meaning
  # NA "no model possible due to lack of df"
  #1 upper and lower parameter fixed at study mean
  #2 upper parameter fixed
  #3 lower parameter fixed
  #4 both limits vary
  if(is.na(results[[2]])){next
  }else if (results[[2]]==1){
    #plot study for visual validation
    png(paste("02studies/01extracted_data/",i,"-",unique(data$study)[i],".png",sep="")) 
    plot(final, xlab = "Day length", ylab = "percentage diapause", main = sub$study[1], sub="upper and lower limit fixed at global mean", log="", col=TRUE)
    dev.off()
  }else if (results[[2]]==2){
    png(paste("02studies/01extracted_data/",i,"-",unique(data$study)[i],".png",sep="")) 
    plot(final, xlab = "Day length", ylab = "percentage diapause", main = sub$study[1], sub="upper limit fixed at global mean", log="", col=TRUE)
    dev.off()
  }else if(results[[2]]==3){
    png(paste("02studies/01extracted_data/",i,"-",unique(data$study)[i],".png",sep=""))
    plot(final,xlab = "Day length", ylab = "percentage diapause", main = sub$study[1], sub="lower limit fixed at global mean", log="", col=TRUE)
    dev.off()
  }else{
    png(paste("02studies/01extracted_data/",i,"-",unique(data$study)[i],".png",sep=""))
    plot(final, xlab = "Day length", ylab = "percentage diapause", main = sub$study[1], sub="upper and lower limit estimated for each pop", log="", col=TRUE)
    dev.off()
    }


    #write these into results table
    coffs<-coeftest(final,vcov = sandwich)[,1:2] #provides estimate and SE
    coffs[,2]<-1/coffs[,2] #SE becomes 1/SE, as these are later weights
    coffs<-as.data.frame(coffs)
    #save slope coefficients
    coffs$group<-substr(rownames(coffs),1,1)
    b<-coffs[coffs$group=="b",]
    c<-coffs[coffs$group=="c",]
    d<-coffs[coffs$group=="d",]
    e<-coffs[coffs$group=="e",]
    


    new_data<-data.frame(b,c,d,e)
    new_data<-new_data[,c(1,2,4,5,7,8,10,11)]
    names(new_data)<-c("b","b-se","c","c-se","d","d_se","e","e_se")
    new_data<-new_data[order(rownames(new_data)),]
    old_data<-ddply(sub, "line.ID", function(z) tail(z,1))
    old_data<-old_data[order(old_data$line.ID),c(1:10,14)]
    results<-cbind(new_data,old_data)
  

write.table(results, "02studies/02output/slopes.txt",append=T,sep="\t",col.names=FALSE)
}#next study
```

