---
title: "analysis"
author: "Jens Joschinski"
date: "April 5, 2018"
output:     
  md_document:
        variant: markdown_github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(RCurl)
library(readr)
library(data.table)
library(textreadr)
library(tidyr)
library(dplyr)
library(stringr)
library(magrittr)
library(geomapdata)
library(geosphere)
library(MASS)
library(lme4)
library(metafor)
```

# issues  
slopes.csv has typo in orius sauteri; and one order missing
lme and nlme do a different weighting, need metafor package
does metafor do internal scaling?
make forest plot of slope estimates (per population)

# General description  
## Aim  
The aim of this project is to correlate climate variability with variability in seasonal timing. Is the slope in seasonal responses a bet-hedging trait, i.e., is it adaptive to spread one's timing in more variable conditions?  


### Overview  

Previous scripts calculated winter variability and winter predictability based on climate station data (30k stations), and various parameters of photoperiodic response curves from published studies (350 populations, 61 studies). This script analyses these datasets.


### Specific description  

The data was generated with R version `r getRversion()`. It requires the datasets "01climate_data/03output/results.txt" and "02studies/02output/slopes.txt", and the locations.txt file from the NOAA server.

### Script  

#### Load the datasets
```{r loadstuff}
url<-"ftp://ftp.ncdc.noaa.gov/pub/data/ghcn/daily/ghcnd-stations.txt"
#this dataset is fixed-width delimited, requiring a few additional steps
locations<-read.fwf(
  file=url
  ,sep="!",na.strings=c("NA","-999.9"), #sep = ! because ! does not exist in dataset - > dataset is fixed-width and should have no additional separators
  widths=c(11, 9, 10, 7,2,35)
)
reslist<-read.table("01climate_data/03output/results.txt",na.string = c("NA","-9999","-999.9"))
names(reslist)<-c("ID","meanwinter","sd_winter","nyears","p","A","phi","c","beta")
climate<-merge(locations,reslist,by=1)
rm(locations)
rm(reslist)
names(climate)<-c("ID","lat","lon","alt","no_idea","name","meanwinter","sd_winter", "nyears","p","A","phi","c","beta")

slopes<-read.table("02studies/02output/slopes.txt")
names(slopes)<-c("ID","b","b_se","c","c_se","d","d_se","e","e_se","ID2","study","pop","spec","order","degN","degE","py")
slopes$spec[slopes$spec=="Orius Sauteri"]<-"Orius sauteri"
slopes<-droplevels(slopes)
climate<-climate[!is.na(climate$meanwinter),] #because these cannot be used anyway
climate$alt[climate$alt == -999.9]<-NA #was somehow not converted to NA during read.table
slopes<-separate(slopes,spec,c("g","s"),sep =" ",remove=FALSE)
#174 data points, 30 studies, 27 species and 21 genera, 10 orders
```

#### statistical approaches  
The "slopes" dataset contains different estimates (e.g. slope and inflection point) of 174 populations (population is the replicate here) in 30 studies, for 27 species, 21 genera and 10 orders. The correct statistical approach should be: 

estimate ~ climate data, random = (study/species/genus/order), 

with the estimate weighted by the inverse of its standard error. One could argue that study can be erased because it is almost entirely covered by species. I will keep it in though, because random effects with nearly 0 explained variance have no effect anyway. The 2 most frequently functions to do the modelling are lme (package nlme) and lmer(package lme4). lme has the advantage that it also can model autocorrelation structures, so I will first stick to that one.  

What significance tests (if any) should be reported?
p-values become difficult to calculate in this analysis, because it is nested, unbalanced and weighted, so conditional F-tests are no option. likelihood-ratio test should work, though it might be inaccurate for small sample sizes. Using a bootstrap version that builds its own Chisquare-like distribution works only for lmer. But p should not be used anyway for that kind of analysis, so I will not report it. Instead I will report the estimate of the coefficient with confidence interval, R² (conditional and marginal, library Mumin) and a plot of prediction + confidence intervals (which ignores random terms). All models will be tested on the easier correlation of latitude and critical day length, and if working, applied to the correlation with predictability/variability.

addendum: the variance of each datapoint is known in meta-analyses (inverse of s.e. in my case), but the "weights"" argument in lm, lme and nlme does not simply weight each point by the weight, but by weight*sigma (a scaling factor). This gives wrong s.e. and I need to use metafor package, function rs.ml.
What should now be reported? standard output requires df and is possibly prone to the same drawbacks as in lme/lmer. The LRT test could work, though again it is not accurate for small n. A bootstrap version (like from pbkrtest) does not seem to exist. I will again ignore p-values and rather report 
1) estimate of coefficient with confint (profile likelihood CIs, bootstrapping if possible), 
2) I² + conf-int (complicated but possible for nested models, see metafor website), and 
3) a plot of prediction with conf intervals (if possible, need to check). 
4) In addition I will do a forest plot of the slope estimates + s.e. for an overview, and a funnel plot (thoguh I do not expect publication bias) 
Generally all outcome statistics are inaccurate, because they expect that variance of each point is known, but I only provide a coarse estimate of vairance that is based on a very low within-population sample size (~4-10 points to get a slope estimate). that needs to be discussed.



#### forest plots of slope and CDL

```{r}
r2<-slopes[order(slopes$e),]
r2$real_se<-1/r2$e_se
plot(y=1:nrow(r2),x=r2$e,xlim=c(8,21),pch=22,cex=0.4,main ="Forest plot of CDL estimates",xlab = "Critical day length",yaxt="n",ylab="")
arrows(x0=r2$e,y0=1:nrow(r2),x1=r2$e+r2$real_se,length=0)
arrows(x0=r2$e,y0=1:nrow(r2),x1=r2$e-r2$real_se,length=0)

r2<-slopes[order(slopes$b),]
r2$real_se<-1/r2$b_se
plot(y=1:nrow(r2),x=r2$b,xlim=c(0,200),pch=22,cex=0.4,main ="Forest plot of slope estimates",xlab = "slope parameter",yaxt="n",ylab="")
arrows(x0=r2$b,y0=1:nrow(r2),x1=r2$b+r2$real_se,length=0)
arrows(x0=r2$b,y0=1:nrow(r2),x1=r2$b-r2$real_se,length=0)
#should maybe exclude a few studies!
```

#### correlation latitude - CDL

The critical day length (day length at which 50 % of all offspring switch to diapause) should correlate with latitude. Earlier studies quote rates of 1-1.5 hours per 5°N. Let's see if that holds for the data in this meta-analysis:
(removed some old preliminary stuff with wrong random structure, general effect is same regradless of weighing and inclusion of random terms)

```{r corr_CDL}
r2<-slopes
r2<-r2[!r2$order=="",]
r2$study[r2$study=="6b"]<-6
r2$study[r2$study=="6c"]<-6
hist(r2$e) #approximately normal




#scaling!
#simplest possible, wrong model
M<-lm(r2$e~r2$degN)
#simplest mixed effects model,ignoring nestedness (several studies per species)
M2<-lme(e~degN,random= ~1|study,data=r2) 
#including full nested structure
M3<-lme(e~degN ,random=~ 1|order/g/s/study,data=r2) 

#removing study, because that is nearly completely included in species
M4<-lme(e~degN, random =~1|order/g/s,data=r2)
#removing species to test whether this is any different from study
M5<-lme(e~degN, random =~ 1|order/g/study,data=r2)

#i think i can settle with M3, the full model, and accept that one random term is nearly 0
summary(M3)#df is 172-30-1, i.e. only accounts for "study" in df calculation, not for higher terms in nested structure-> p unreliable
plot(M3)
qqnorm(resid(M3))
#getting p-values (for quick overview only)
M3ml<-lme(e~degN ,random=~ 1|order/g/s/study,data=r2,method="ML") 
M3r<-lme(e~1 ,random=~ 1|order/g/s/study,data=r2,method="ML") 
anova(M3ml,M3r) 
#unreliable for smaller sample size, better is parametric bootstrap calculation which requires no chisquare-distribution
M3lmer<-lmer(e~degN+(1|order/g/s/study),data=r2,REML=F)
M3r_lmer<-lmer(e~1+(1|order/g/s/study),data=r2,REML=F)
PBmodcomp(M3lmer,M3r_lmer) #108 sec. 1000 samples, 0 extremes, 995 used samples; p = 0.001004



#same models, but weighing by s.e. of e estimate 
r2$e_se[r2$e_se>100]<-100
Mb<-lm(r2$e~r2$degN, weights = as.numeric(r2$e_se))
M2b<-lmer(e~degN + (1|study),data=r2,weights=r2$e_se)

M3b<-lme(e~degN ,random=~ 1|order/g/s/study,data=r2, weights = varPower(~e_se))
#does not work, simply weights = ~e_se is wrong.
         #png("cdl_vs_lat.png")
plot(r2$e~r2$degN, bg = r2$study,pch=22,main = "Correlation of critical day length and latitude", xlab ="latitude",ylab="critical day length")

M<-lm(r2$e~r2$degN)
abline(M)
coef(M)[2]*5  #0.81 hours per 5 degree latitude
text(20,18, "slope = 0.81 hours/5°N\nR²=0.69")

#dev.off()
hist(r2$e_se)
r2[r2$e_se>500,]
#this is because $e_se is actually 1/s.e.,and the curves of these pops seem on the bring of being overfitted (and hence hav low s.e.)
r2$e_se[r2$e_se>100]<-100
hist(r2$e_se,breaks=100)

M2<-lm(r2$e~r2$degN, weights = as.numeric(r2$e_se))
plot(r2$e~r2$degN, bg = r2$study,pch=22,main = "Correlation of critical day length and latitude (weighted)", xlab ="latitude",ylab="critical day length")
abline(M2)
coef(M2)[2]*5  #0.81 hours per 5 degree latitude
text(20,18, "slope = 0.84 hours/5°N\nR²=0.66")


#png("cdl_vs_lat_weighted.png")
plot(r2$e~r2$degN, bg = "grey",pch=21,cex=(r2$e_se/100)+0.5, main = "delay in photoperiodic response vs latitude", xlab = "Latitude (°N)", ylab = "Critical photoperiod")
abline(M2,lty=2)
for( i in 2:length(unique(r2$study))){
  a<-r2[r2$study==unique(r2$study)[i],]
  a<-a[is.na(a$e)== FALSE,]
  a<-a[is.na(a$degN)==FALSE,]
  points(a$e~a$degN, pch=21, bg=i,cex=(a$e_se/100)+0.5)
  M<-lm(a$e~a$degN,weights=a$e_se)
 lines(x= a$degN,y= predict(M),col="grey",xpd=T)
}
text(20,18, "slope = 0.93 hours/5°N\nR²=0.39")
#dev.off()

#actually the relationship does not seem to be linear
boxcox(r2$e~r2$degN)
M1<-lm(r2$e~r2$degN)
M2<-lm(r2$e^0.465 ~ r2$degN)
#plot(M1)
#plot(M2)
summary(M1)
summary(M2)
#not much difference, can keep linear model

mixed<-lmer(e~degN + (1|study),data=r2,weights=r2$e_se) #lme4,no p
mixed<-lmer(e~degN + (1|order/g/s/study),data=r2)
nlme(e~degN,random = 1|order/g/s/study,data=r2) #nlme,p
r2$preds<-predict(mixed)
plot(r2$e~r2$degN, bg = "grey",pch=21,cex=(r2$e_se/100)+0.5, main = "delay in photoperiodic response vs latitude", xlab = "Latitude (°N)", ylab = "Critical photoperiod")
#abline(M2,lty=2)
for( i in 2:length(unique(r2$study))){

  a<-r2[r2$study==unique(r2$study)[i],]
  a<-a[is.na(a$e)== FALSE,]
  a<-a[is.na(a$degN)==FALSE,]
  points(x=a$degN,y=a$e,pch=21,bg=i)
 lines(x= a$degN,y= a$preds,col=i,xpd=T)
}
text(20,18, "slope = 0.93 hours/5°N\nR²=0.39")

plot(r2$c~r2$degN)
plot(r2$d~r2$degN)

#studies without estimate of d
#9,11,17,18,23, 29,30, 42,51,54,57,70
dsub<-r2[!r2$study  %in% c(9,11,17,18,23,24,29,30,42,51,54,57,70),]
dsub<-droplevels(dsub)
dsub$d_se[dsub$d_se>100]<-100
plot(dsub$d~dsub$degN,bg=dsub$study,pch=22)
mixedd<-lmer(d~degN + (1|study),data=dsub)
dsub$preds<-predict(mixedd)
plot(dsub$d~dsub$degN, bg = "grey",pch=21,cex=0.5, main="upper limit vs latitude", xlab = "Latitude (°N)", ylab ="d")
#abline(M2,lty=2)
for( i in 2:length(unique(dsub$study))){

  a<-dsub[dsub$study==unique(dsub$study)[i],]
  a<-a[is.na(a$d)== FALSE,]
  a<-a[is.na(a$degN)==FALSE,]
  points(x=a$degN,y=a$d,pch=21,bg=i)
 lines(x= a$degN,y= a$preds,col=i,xpd=T)
}
text(20,18, "slope = 0.93 hours/5°N\nR²=0.39")

```

The estimate of 1 h per 5° N is not too bad, overall diapause becomes 50 min earlier per 5°.



#### correlation with climate data  
One would expect that this curve fits well to mean winter onset given latitude, and the climate data allows testing that. Overview:

```{r clim_M}
plot(climate$meanwinter~climate$lat,pch=22,cex=0.1, main ="Mean winter onset vs. latitude")
hist(slopes$degN,breaks=100) #for comparison
```

It is possibly a bad idea to use any climate above 70°N. The highest latitude in the studies was 69.05 °N. The apparent cap at ~25°N is because winter is not defined for warm climates (winter never arrives). The lowest latitude in the studies is at 18.3°N. 
Refined overview:  

```{r minus70}
climate<-climate[climate$lat<=70,]
plot(climate$meanwinter~climate$lat,pch=22,cex=0.1, main ="Mean winter onset vs. latitude")
M<-lm(climate$meanwinter~climate$lat)
```

Mean winter decreases by 2.6 days per ° latitude = 13 days per 5°, so an organism needs to react to a day length equal to 13 days earlier in the year per 5°N. The correct calculation of day length at a given latitude for a given day is difficult: https://en.wikipedia.org/wiki/Sunrise_equation
luckily there is a package that solves that.

```{r climate_CDL}
M<-lm(climate$meanwinter~climate$lat)
#expected_dl = daylength(latitude,day)
#with day = day from regression on M +182 days because the "year" calculated from climate data starts in july
slopes$expdl<-daylength(slopes$degN,
              182+coef(M)[1]+coef(M)[2]*slopes$degN
)
#the switch to diapause usually takes some time, e.g. sexual offspring must be produced and mature. lets try 1 - 3 weeks
slopes$expdl7<-daylength(slopes$degN, 182+coef(M)[1]+coef(M)[2]*slopes$degN-7)
slopes$expdl14<-daylength(slopes$degN,182+coef(M)[1]+coef(M)[2]*slopes$degN-14)
slopes$expdl21<-daylength(slopes$degN,182+coef(M)[1]+coef(M)[2]*slopes$degN-21)
plot(slopes$expdl~slopes$degN,main = "how the CDL should vary with latitude",xlab ="latitude",ylab ="expected CDL")
points(slopes$expdl7~slopes$degN,col=2)
points(slopes$expdl14~slopes$degN,col=3)
points(slopes$expdl21~slopes$degN,col=4)
```

#### combining these two  
integrating this into the curve of CDL vs latitude (mostly copy of above code)

```{r CDL_and_expected}
r2<-slopes
r2<-separate(r2,col=1, into = c("study","pop"), sep ="-",remove=FALSE)
r2$e<-as.numeric(r2$e)
r2$degN<-as.numeric(r2$degN)
r2$e[r2$e>100]<-NA
r2$degN[r2$degN>80] <- NA
r2$study[r2$study=="6b"]<-6
r2$study<-as.integer(r2$study)
#png("cdl_vs_lat.png")
plot(r2$e~r2$degN, bg = r2$study,pch=22,main = "Correlation of critical day length and latitude", xlab ="latitude",ylab="critical day length")
points(x=r2$degN, y = r2$expdl,cex=0.3)
#points(r2$expdl7~r2$degN,col=2,cex=0.3)
#points(r2$expdl14~r2$degN,col=3,cex=0.3)
points(r2$expdl21~r2$degN,col=4,cex=0.3)


plot(r2$e~r2$expdl,main = "Correlation of Critical day length and expected CDL",xlab ="expected by climate data",ylab="CDL from studies")
abline(lm(r2$e~r2$expdl))
summary(lm(r2$e~r2$expdl))
```


Now to the main part of this study: correlating slope of the PRC with climate data

1. histograms of all variables
```{r hist, include = FALSE}
hist(climate$alt)
climate$sq_alt <-sqrt(climate$alt) #few NAs producded
hist(climate$sq_alt,breaks=100)

hist(climate$meanwinter,breaks=100)
hist(climate$sd_winter,breaks=100)
climate$capped_sd<-climate$sd_winter
climate$capped_sd[climate$capped_sd>50]<-50

hist(climate$nyears,breaks=50)

hist(climate$beta_y,breaks=100)#this is considerably less than in vasseur & Yodzis!
```


checking whether the nls regression makes sense
```{r nls ,include =F}
p<-climate
hist(p$amplitude)
hist(p$`phase angle`)
hist(p$intercept)



p$intercept[p$intercept<(-100)]<-(-100)
p$intercept[p$intercept>200]<-200
p$intercept<-p$intercept+abs(min(p$intercept,na.rm=T))
p$amplitude[p$amplitude>250]<-250
p<-p[!is.na(p$intercept),]
plot(p$lat~p$lon,bg = rgb(p$intercept,0,p$intercept,maxColorValue = max(p$intercept)),col=NA,pch=22,cex=0.3,main = "mean temperature from nls regression (intercept)")
plot(p$lat~p$lon,bg = rgb(p$amp,0,p$amp,maxColorValue = max(p$amp)),cex=0.3,pch=22,col=NA,main ="difference between summer and witner from nls regression (amplitude)")
plot(p$lat~p$lon,bg=rgb(p$`phase angle`,0,p$`phase angle`,maxColorValue = max(p$`phase angle`)),cex=0.3,pch=22,col=NA,main = "midsummer from nls regression (phase angle)")
```

visualisation mean winter, sd(winter), predictability, beta
```{r visualisation}
#png("mean-winter.png")
p<-climate
p<-p[!is.na(p$meanwinter),]
plot(p$lat~p$lon,bg = rgb(p$meanwinter,p$meanwinter,0,maxColorValue = max(p$meanwinter)),cex=0.3,pch=22,col=NA, main ="mean winter onset",xlab="",ylab="")
#dev.off()

p<-climate
p<-p[!is.na(p$capped_sd),]
p$capped_sd[p$capped_sd>20]<-20
p<-p[p$nyears>8,]
#png("sd-winter.png")
plot(p$lat~p$lon,bg = rgb(p$capped_sd,p$capped_sd,0,maxColorValue = max(p$capped_sd)),cex=0.3,pch=22,col=NA, main ="sd winter onset, capped at 20",xlab="",ylab="")
#dev.off()


p<-climate[climate$nyears>25,]
p<-p[!is.na(p$beta_year),]
p$beta_year[p$beta_year>1.2]<-1.2 #1.2% of all data
p$beta_year[p$beta_year<0]<-0 #4.6%

#range(p$unpredictability)
#png("predictability-winter.png")
plot(p$lat~p$lon,bg = rgb(1,max(p$beta_year)-p$beta_year+0.0001,max(p$beta_year)-p$beta_year+0.0001,maxColorValue = max(p$beta_year+0.001)),cex=0.3,pch=22,col=NA, main ="unpredictability",sub="dark low standard deviation in slopes",xlab="",ylab="")
#dev.off()



p<-climate[climate$nyears>25,]
p<-p[!is.na(p$beta_month),]
p$beta_year[p$beta_month>1.2]<-1.2 #1.2% of all data
p$beta_year[p$beta_year<0]<-0 #4.6%

#range(p$unpredictability)
#png("predictability-winter.png")
plot(p$lat~p$lon,bg = rgb(1,max(p$beta_year)-p$beta_year+0.0001,max(p$beta_year)-p$beta_year+0.0001,maxColorValue = max(p$beta_year+0.001)),cex=0.3,pch=22,col=NA, main ="unpredictability",sub="dark low standard deviation in slopes",xlab="",ylab="")
#dev.off()
```

Does winter variability or predictability correlate with lat/alt or amplitude?
```{r corr_climate}
p$amplitude[p$amplitude>250]<-250
plot(p$sd_winter~p$lat,pch=22,cex=0.1)
plot(p$sd_winter~p$sq_alt,pch=22,cex=0.1)
plot(p$sd_winter~p$amplitude,pch=22,cex=0.1)

plot(p$unpredictability~p$lat,pch=22,cex=0.1)
plot(p$unpredictability~p$amplitude,pch=22,cex=0.1)

#summary(lm(p$unpredictability~p$lat+p$lon+p$sq_alt))
#summary(lm(p$unpredictability~p$lat+p$lon+p$alt))
#summary(lm(p$unpredictability~p$amplitude))

plot(p$capped_sd~p$unpredictability,pch=22,cex=0.1)
summary(lm(p$capped_sd~p$unpredictability))
#summary(lm(p$sd_winter~p$lat+p$sq_alt)) #R²=0
```
```{r beta_climate}
plot(climate$beta~climate$lat,pch=22,cex=0.1)
plot(climate$beta~climate$amplitude,pch=22,cex=0.1)
plot(climate$beta~climate$lon,pch=22,cex=0.1)
plot(climate$beta~climate$meanwinter,pch=22,cex=0.1)
plot(climate$beta~climate$alt,pch=22,cex=0.1)
plot(climate$beta~climate$sd_winter,pch=22,cex=0.1)
plot(climate$beta~climate$unpredictability,pch=22,cex=0.1)
```



correlate slopes with climate data:
Take the 5 closest climate stations in a 5° radius, calculate sd,predictability,color and mean of these weighted by inverse of euclidian distance.

```{r combine}
slopes$meanwinter<-NA
slopes$sd_winter<-NA
slopes$unpredictability<-NA
slopes$nyears<-NA
slopes$beta<-NA 

for ( i in 1:nrow(slopes)){
  #reduce to +-5 °
  sub<-climate[between(climate$lat,slopes[i,10]-5,slopes[i,10]+5)& between(climate$lon,slopes[i,11]-5,slopes[i,11]+5),]
  
  sub$diffN<-sub$lat-slopes[i,10] #calculate distance in latitude
  sub$diffE<-sub$lon-slopes[i,11] #same for longitude
  sub$diff<-sqrt(sub$diffN^2+sub$diffE^2) #euclidian distance
  sub<-arrange(sub,diff)[1:5,] #sort and take 5 lowest values
  
  slopes$meanwinter[i]<-weighted.mean(sub$meanwinter,1/sub$diff)
  slopes$sd_winter[i]<-weighted.mean(sub$sd_winter,1/sub$diff)
  slopes$unpredictability[i]<-weighted.mean(sub$unpredictability,1/sub$diff)
  slopes$nyears[i]<-weighted.mean(sub$nyears,1/sub$diff)
  slopes$beta[i]<-weighted.mean(sub$beta,1/sub$diff)

}
slopes$b<-abs(slopes$b)
slopes<-slopes[!is.na(slopes$meanwinter),]
```



Now the slopes from the studies can be plotted against climate variables (+modelling)
```{r resultschunk}
r2<-separate(slopes,col=1, into = c("study","pop"), sep ="-",remove=FALSE)
r2$e<-as.numeric(r2$e)
r2$degN<-as.numeric(r2$degN)
r2$study[r2$study=="6b"]<-6
r2$study<-as.integer(r2$study)

plot(r2$e~r2$meanwinter,xlab = "mean winter",ylab="CDL",bg=palette(rainbow(42)),pch=22,sub="black line: prediction with 1|study")
for (i in unique(r2$study)){  #make grey lines for each individual study(with line thickness~no of populations)
t<-r2[r2$study==i,]
M<-lm(t$e~t$meanwinter)
if (sum(is.na(coef(M)))==0){lines(x=t$meanwinter, y= predict(M),col="grey",lwd=nrow(t)/10)
  }#if clause makes sure model worked
}

mixed<-lmer(e~meanwinter + (1|study),data=r2)
r2$pred<-predict(mixed)
lines(x=range(r2$meanwinter),y=summary(mixed)$coefficients[1,1]+range(r2$meanwinter)*summary(mixed)$coefficients[2,1],lwd=2) #coef(mixed) gives many coefs for all random terms

#same code for sd_winter and predictability
plot(r2$b~r2$sd_winter,xlab = "standard deviation in winter",ylab = "slope of PRC",bg=palette(rainbow(42)),pch=22,sub="black line: prediction with 1|study")
for (i in unique(r2$study)){
t<-r2[r2$study==i,]
M<-lm(t$b~t$sd_winter)
if (sum(is.na(coef(M)))==0){lines(x=t$sd_winter, y= predict(M),col="grey",lwd=nrow(t)/10)
  }
}
mixed<-lmer(b~sd_winter + (1|study),data=r2)
r2$pred<-predict(mixed)
lines(x=range(r2$sd_winter),y=summary(mixed)$coefficients[1,1]+ range(r2$sd_winter)*summary(mixed)$coefficients[2,1],lwd=2)
#quite severe variance heterogeneity


plot(r2$b~r2$beta,xlab="color of noise",ylab="slope of PRC",bg=palette(rainbow(42)),pch=22)
for (i in unique(r2$study)){
t<-r2[r2$study==i,]
M<-lm(t$b~t$beta)
if (sum(is.na(coef(M)))==0){lines(x=t$beta, y= predict(M),col="grey",lwd=nrow(t)/10)
  }
}
mixed<-lmer(b~beta + (1|study),data=r2)
r2$pred<-predict(mixed)
lines(x=range(r2$beta),y=summary(mixed)$coefficients[1,1]+ range(r2$beta)*summary(mixed)$coefficients[2,1],lwd=2)



r2<-r2[!is.na(r2$unpredictability),]

plot(r2$b~r2$unpredictability,xlab = "winter unpredictability",ylab = "slope of PRC",bg=palette(rainbow(42)),pch=22)
for (i in unique(r2$study)){
t<-r2[r2$study==i,]
t<-t[!is.na(t$unpredictability),]
M<-lm(t$b~t$unpredictability)
if (sum(is.na(coef(M)))==0){lines(x=t$unpredictability, y= predict(M),col="grey",lwd=nrow(t)/10)
  }
}
mixed<-lmer(b~unpredictability + (1|study),data=r2)
r2$pred<-predict(mixed)
lines(x=range(r2$unpredictability),y=summary(mixed)$coefficients[1,1]+ range(r2$unpredictability)*summary(mixed)$coefficients[2,1],lwd=2)
#quite severe variance heterogeneity



mixed_comp<-lmer(b~sd_winter*unpredictability+(1|study),data=r2)
m2<-lmer(b~sd_winter+unpredictability+(1|study),data=r2)
m3<-lmer(b~unpredictability+(1|study),data=r2)
m4<-lmer(b~sd_winter+(1|study),data=r2)

anova(mixed_comp,m2)
anova(m2,m3)
anova(m2,m4)
#should exchange that with non-p statistics
#also need to correct for variance heterogeneity
#and include weights (inverse of s.e. of b)



```


The slope estimates of the individual dose-response curve vary by study (some are ~ 500, others 10). They need to be scaled on the study-level, so that they are 0-1 in each study.
Everything else is copy of chunk above

```{r scaled}
#scale slope by study
r2<-r2%>%
  group_by(study)%>%
  mutate(b=scale(b))%>%
  ungroup()

plot(r2$b~r2$sd_winter,xlab = "standard deviation in winter",ylab = "slope of PRC (scaled by study)",bg=palette(rainbow(42)),pch=22)
mixed<-lmer(b~sd_winter + (1|study),data=r2)
r2$pred<-predict(mixed)
lines(x=range(r2$sd_winter),y=summary(mixed)$coefficients[1,1]+ range(r2$sd_winter)*summary(mixed)$coefficients[2,1],lwd=2)
#quite severe variance heterogeneity

backup<-r2
r2<-r2[!is.na(r2$beta),]
plot(r2$b~r2$beta,xlab="color of noise",ylab="slope of PRC(scaled by study",bg=palette(rainbow(42)),pch=22)
mixed<-lmer(b~beta + (1|study),data=r2)
#r2$pred<-predict(mixed)
#lines(x=range(r2$beta),y=summary(mixed)$coefficients[1,1]+ range(r2$beta)*summary(mixed)$coefficients[2,1],lwd=2)

r2<-backup

plot(r2$b~r2$unpredictability,xlab = "winter unpredictability (scaled by study)",ylab = "slope of PRC(scaled by study)",bg=palette(rainbow(42)),pch=22)
mixed<-lmer(b~unpredictability + (1|study),data=r2)
r2$pred<-predict(mixed)
lines(x=range(r2$unpredictability),y=summary(mixed)$coefficients[1,1]+ range(r2$unpredictability)*summary(mixed)$coefficients[2,1],lwd=2)

mixed_comp<-lmer(b~sd_winter*unpredictability+(1|study),data=r2)
m2<-lmer(b~sd_winter+unpredictability+(1|study),data=r2)
m3<-lmer(b~unpredictability+(1|study),data=r2)
m4<-lmer(b~sd_winter+(1|study),data=r2)

anova(mixed_comp,m2)
anova(m2,m3)
anova(m2,m4)


#to see whether this makes sense
r2<-r2%>%
  group_by(study)%>%
  mutate(e=scale(e))%>%
  ungroup()
plot(r2$e~r2$meanwinter,xlab = "mean winter (scales by study)",ylab="CDL(scaled by study)",bg=palette(rainbow(42)),pch=22)
mixed<-lmer(e~meanwinter + (1|study),data=r2)
r2$pred<-predict(mixed)
lines(x=range(r2$meanwinter),y=summary(mixed)$coefficients[1,1]+range(r2$meanwinter)*summary(mixed)$coefficients[2,1],lwd=2)
```

