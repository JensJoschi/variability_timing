---
title: "analysis"
author: "Jens Joschinski"
date: "April 5, 2018"
output:     
  md_document:
        variant: markdown_github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
#library(RCurl)
#library(readr)
#library(data.table)
#library(textreadr)
#library(tidyr)
#library(dplyr)
#library(stringr)
#library(magrittr)
#library(geomapdata)
library(geosphere)
#library(MASS)
#library(lme4)
library(nlme)
library(metafor)
library(maps)
#library(ggplot2)
library(MuMIn)
```


# General description  
## Project aim  
The aim of this project is to correlate means and variance of diapause timing with climate means and climate predictability.

## Script overview  

Previous scripts calculated winter onset means and predictability based on climate station data (30k stations), and various parameters of photoperiodic response curves from published studies (~175 populations,28 studies). This script analyses these datasets.


### Specific description  

The data was generated with R version `r getRversion()` (3.44). It requires the datasets "01climate_data/03output/results.txt" and "02studies/02output/slopes_clean.txt", and the locations.txt file from the NOAA server.

In this script we do:
1. maps of winter onset and winter predictability (day length and 2x temperature)

2a. correlate critical day length (CDL) with latitude. This is not quite as the hypotheses, but allows comparison to historical data
2b. correlate day length of mean winter onset with latitude. also for comparison with historical data.

3. correlate critical day (CD) as interaction of mean winter onset and day length predictability
4. Between-treatments variance was correlated with day length predictability 5. Within-treatment variance was correlated with an interaction of day length and temperature predictabilities 
 
### statistical approaches  
The correct statistical approach should be:

estimate ~ climate data, random = (study/species/genus/order), 

with the estimate weighted by the inverse of its variance. The funnel plots showed however that inverse variance does not work, so I take the number of points on the sloped part as sample-size weighing (see manuscript and drc script). Usually meta-analyses are conducted with metafor, because this package can weigh each data point by its inverse variance, whereas lme/lmer make the weights proportional to an unknown constant. In this case the lme/lmer version is correct though, because the sample size should be only proportional to inverse variance. 

# Script  

## Overview of studies  

```{r load_slopes}
slopes<-read.table("02studies/02output/slopes_clean.txt",header=T,sep="\t")

table(slopes$region)
paste(n_distinct(slopes$order),"orders")
paste(n_distinct(slopes$genus),"genera")
paste(n_distinct(slopes$spec),"species")


#one of the studies has three species
slopes$ID[slopes$ID=="kimura_geogr_2"]<-"kimura_geogr_1"
slopes$ID[slopes$ID=="kimura_BJLS_2"]<-"kimura_BJLS"
slopes$ID[slopes$ID=="kimura_BJLS_3"]<-"kimura_BJLS"
slopes$ID[slopes$ID=="kimura_BJLS_4"]<-"kimura_BJLS"
slopes$ID<-droplevels(slopes$ID)
paste(nrow(slopes),"populations")
paste(n_distinct(slopes$ID),"studies")

slopes$col<-hsv((as.numeric(slopes$order)-1)/8,1,1) # 8 different colors, 1 per invertebrate order
slopes$col2<-hsv((as.numeric(slopes$order)-1)/8,0.5,1)
slopes<-slopes[order(slopes$order),]
```

## climate data  
As climate dataset I chose the parameters (5 days below 10°C), a combination that is close to e.g. halkett 2004, and results in a mean winter onset in mid-october (when many animals start their diapause)

```{r load}
url<-"ghcnd-stations.txt"
#"ftp://ftp.ncdc.noaa.gov/pub/data/ghcn/daily/ghcnd-stations.txt"
#this dataset is fixed-width delimited, requiring a few additional steps
locations<-read.fwf(
  file=url
  ,sep="!",na.strings=c("NA","-999.9"), #sep = ! because ! does not exist in dataset - > dataset is fixed-width and should have no additional separators
  widths=c(11, 9, 10, 7,2,35)
)
#reslist<-read.table("01climate_data/03output/results.txt",na.string = c("NA","-9999","-999.9"))  <-- this is with old thres of 5°C
reslist<-read.table("01climate_data/03output/results_100-5.txt",na.string = c("NA","-9999","-999.9"))
names(reslist)<-c("ID","meanwinter","sd_winter","p","nyears","ndays_300","ndays_350","ndays_365")
reslist<-reslist[1:26804,] #the same data was appended twice
climate<-merge(locations,reslist,by=1)
rm(reslist)
names(climate)<-c("ID","lat","lon","alt","name","no_idea","meanwinter","sd_winter", "p",  "nyears" ,  "ndays_300"  ,"ndays_350",  "ndays_365" )

climate<-climate[!is.na(climate$meanwinter),] #because these cannot be used anyway
beta<-read.table("01climate_data/03output/beta.txt",header=T)
climate<-merge(climate,beta,by=1)

climate<-climate[climate$lat<70,]
#calculate day length:
#Day length changes not only with latitude but also with day of year
#The correct calculation of day length at a given latitude for a given day is difficult: https://en.wikipedia.org/wiki/Sunrise_equation
#luckily there is a package that solves that.

climate$dl <- daylength(climate$lat,climate$meanwinter+182)
```


## maps  

_map of winter onset  _  
```{r w_on}
x<-climate$meanwinter
x<-x-min(x)
x<-x/(max(x)) #values between 0 and 1
#large values (winter is late in year, high number) should be red
#range should be: 192,0,0 (red) to 30,100,200 (blue)

r<- x * 162
r <- r + 30
g<-100 - (x * 100)
b<-200 - (x * 200)

#mapWorld <- borders("world", colour="gray50", fill="gray50") # create a layer of borders
svg("w_on_10C5d.svg",width = 14 ,height = 7,pointsize=12)
mp <- ggplot() + 
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = 0), title=element_blank(), axis.text=element_blank(), axis.title = element_blank(), axis.ticks = element_blank(), plot.margin = unit(c(0,0,0,0),units= "cm")) #or rgb(30,100,200,maxColorValue = 255)

mp+ 
  borders("world", colour="gray50", fill="gray50")+
  geom_point(aes(x=climate$lon, y=climate$lat), col = rgb(r,g,b,maxColorValue = 255), size=0.4)+
  geom_point(aes(x=slopes$degE,y=slopes$degN), col = 1, size=0.6)
dev.off()
```

_map of day length at winter onset_

```{r w_dl}
x<-climate$dl
length(x[x>16])/length(x)
x[x>16]<-16
x<-24-x #x is night length now, high values = short days
#high values should be red ( winter very late in year, under very short days)

x<-x-min(x)
x<-x/(max(x)) #values between 0 and 1

r<- x * 162
r <- r + 30
g<-100 - (x * 100)
b<-200 - (x * 200)


svg("w_dl_10C5d.svg",width = 14 ,height = 7,pointsize=12)
mp <- ggplot() + 
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = 0), title=element_blank(), axis.text=element_blank(), axis.title = element_blank(), axis.ticks = element_blank(), plot.margin = unit(c(0,0,0,0),units= "cm")) #or rgb(30,100,200,maxColorValue = 255)

mp+ 
  borders("world", colour="gray50", fill="gray50")+
  geom_point(aes(x=climate$lon, y=climate$lat), col = rgb(r,g,b,maxColorValue = 255), size=0.4)+
  geom_point(aes(x=slopes$degE,y=slopes$degN), col = 1, size=0.6)
dev.off()
```
_Map of winter predictability(by day length)_  

Variability defined as standard deeviation of winter onset. 
```{r w_p_dl}
x<-climate$sd_winter
x[x>30]<-30 #capped to make plotting sensible
x<-x-min(x)
x<-x/(max(x)) #values between 0 and 1
#large values (high standard deviation) should be red

r<- x * 162
r <- r + 30
g<-100 - (x * 100)
b<-200 - (x * 200)

#mapWorld <- borders("world", colour="gray50", fill="gray50") # create a layer of borders
svg("w_sd_10C5d.svg",width = 14 ,height = 7,pointsize=12)
mp <- ggplot() + 
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = 0), title=element_blank(), axis.text=element_blank(), axis.title = element_blank(), axis.ticks = element_blank(), plot.margin = unit(c(0,0,0,0),units= "cm")) #or rgb(30,100,200,maxColorValue = 255)

mp+ 
  borders("world", colour="gray50", fill="gray50")+
  geom_point(aes(x=climate$lon, y=climate$lat), col = rgb(r,g,b,maxColorValue = 255), size=0.4)+
    geom_point(aes(x=slopes$degE,y=slopes$degN), col = 1, size=0.6)
dev.off()
```

_predictability by temperature _  
This way of calculating winter unpredictability is the standard deviation in slopes of a temperature regression, 30 days before winter onset of each year
```{r w_p_t}
x<-climate[!is.na(climate$p),]
nrow(x[x$p>4,])/nrow(x)
x$p[x$p>4]<-4 #capped to make plotting sensible
x$p<-x$p-min(x$p)

x$p<-x$p/(max(x$p)) #values between 0 and 1
#large values (high standard deviation) should be red



r<- x$p * 162
r <- r + 30
g<-100 - (x$p * 100)
b<-200 - (x$p * 200)


svg("w_p_10C5d.svg",width = 14 ,height = 7,pointsize=12)
mp <- ggplot() + 
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = 0), title=element_blank(), axis.text=element_blank(), axis.title = element_blank(), axis.ticks = element_blank(), plot.margin = unit(c(0,0,0,0),units= "cm")) #or rgb(30,100,200,maxColorValue = 255)

mp+ 
  borders("world", colour="gray50", fill="gray50")+
  geom_point(aes(x=x$lon, y=x$lat), col = rgb(r,g,b,maxColorValue = 255), size=0.4)+
    geom_point(aes(x=slopes$degE,y=slopes$degN), col = 1, size=0.6)
dev.off()
```


_predictability as colour of noise  _  

```{r w_p_beta}
x<-climate[!is.na(climate$beta),]
nrow(x[x$beta>2,])/nrow(x)
x$beta[x$beta>2]<-2 #capped to make plotting sensible
x$beta[x$beta<(-2)]<-(-2) #capped to make plotting sensible
x$beta<-x$beta-min(x$beta)

x$beta<-x$beta/(max(x$beta)) #values between 0 and 1
#large values (high standard deviation) should be red



r<- x$beta * 162
r <- r + 30
g<-100 - (x$beta * 100)
b<-200 - (x$beta * 200)


svg("w_b_10C5d.svg",width = 14 ,height = 7,pointsize=12)
mp <- ggplot() + 
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_rect(fill = 0), title=element_blank(), axis.text=element_blank(), axis.title = element_blank(), axis.ticks = element_blank(), plot.margin = unit(c(0,0,0,0),units= "cm")) #or rgb(30,100,200,maxColorValue = 255)

mp+ 
  borders("world", colour="gray50", fill="gray50")+
  geom_point(aes(x=x$lon, y=x$lat), col = rgb(r,g,b,maxColorValue = 255), size=0.4)+
    geom_point(aes(x=slopes$degE,y=slopes$degN), col = 1, size=0.6)
dev.off()
```

### how do these climate pics change with parameters?  
The following chunk correlates day length at winter onset with latitude, for a variety of parameter combinations (currently commented out). It also saves the slope estimates.
It is currently disabled so that the script is not slowed down. in addition, running it will reload the climate data and erase all changes (e.g. climate$dl) from chunk4 ("load")
```{r sensitivity}
dontrun<-function(){
threshlist <-seq(0,150,5)
t2list <-5#c(5,10,15)
Z<-1
coeflist<-rep(NA,length(threshlist)*length(t2list))


for(threloop in 1:length(threshlist)){
  threshold<-threshlist[threloop]
  for (t2loop in 1:length(t2list)){
    t2<-t2list[t2loop]
    reslist<-read.table(paste("01climate_data/03output/results_",threshold,"-",t2,".txt",sep=""))
    names(reslist)<-c("ID","meanwinter","sd_winter","p","nyears","ndays_300","ndays_350","ndays_365")
    climate<-merge(locations,reslist,by=1)
rm(reslist)
names(climate)<-c("ID","lat","lon","alt","name","no_idea","meanwinter","sd_winter",   "p", "nyears" , "ndays_300"  ,"ndays_350",  "ndays_365" )

climate<-climate[!is.na(climate$meanwinter),] 
climate<-climate[climate$lat<70,]
climate<-climate[climate$lat>20,]


climate$expdl<-daylength(climate$lat,climate$meanwinter+182)
coeflist[Z]<-coef(lm(climate$expdl~climate$lat))[2]

#png(paste("results_",threshold,"-",t2,".png",sep=""))
#plot(climate$expdl~climate$lat,pch=22,bg=1,col=NA,cex=0.1)
#abline(lm(climate$expdl~climate$lat),col=2)
#text(x=min(climate$lat)+5,y= min(climate$expdl)+1,paste("slope:",round(coeflist[Z],2)*5))
#text(x=60,y=min(climate$expdl)+1,paste("median winter:",182+round(median(climate$meanwinter))))
#dev.off()

Z<-Z+1
}}

svg("slope_par.svg",pointsize=12)
par(mar=c(5,5,3,2)+0.1)
plot(x=threshlist/10, y=coeflist[seq(1,length(threshlist)*length(t2list),length(t2list))]*5, xlab="T threshold (°C)", ylab="Slope coefficient (h/5°N)", bty="n", type="l", lwd=3, yaxt="n", cex.lab=1.5, cex.axis=1.5,ylim=range(coeflist)*5)
for (lin in 1:length(t2list)){
  lines(x=threshlist/10,y=coeflist[seq(lin,length(threshlist)*length(t2list),length(t2list))]*5,col=col_def[lin],lwd=3,lty=lin)
}
axis(2,at=c(-0.5,0,0.5,1,1.5), cex.axis=1.5)
dev.off()
}
```


## Danilevskys rule  
### correlation day length at winter onset with latitude  

Danilevsky argued that organisms change their day length response by 1 hour per 5°N. Is that correct? Given the climate data, what is the optimal diapause shift with latitude?

```{r cor}
restore<-climate
climate<-climate[climate$lat>20,]

svg("corr_dl_lat_10C5d.svg")
par(mar=c(5,5,3,2)+0.1)
plot(climate$dl~climate$lat,pch=22,cex=0.2,xlab = "Latitude",ylab = "Day length at winter onset",main="",col=NA,bg=1,bty="n",yaxt="n",cex.axis=1.5,cex.lab=1.5)
axis(2,at=c(4,8,12,16,20,24),cex.axis=1.5)
M<-lm(climate$dl~climate$lat)
lines(x=c(20,70),y=coef(M)[1]+c(20,70)*coef(M)[2],lwd=4,col="darkgrey")
#text(60,8,"R² = 0.54")
dev.off()
coef(M)[2]*5

#logs<-boxcox(M,lambda=seq(-5,5,0.1))
#logs$x[which(logs$y==max(logs$y))]
pw<-climate$dl^(-4.5)
M2<-lm(pw~climate$lat)
plot(climate$dl~climate$lat,pch=22,cex=0.2,xlab = "Latitude",ylab = "Day length at winter onset",main="",col=NA,bg=1,bty="n",yaxt="n")
points(x=seq(0,70,length.out=1000),y=(coef(M2)[1]+seq(0,70,length.out = 1000)*coef(M2)[2])^(1/(-4.5)),col=2)

svg("concept.svg")
par(mar=c(5,5,3,2)+0.1)
plot(daylength(0,1:365), xlab="Julian day", ylab = "Day length", cex.axis=1.5, cex.lab=1.5, bty = "n", main="", type="l", lwd=3, ylim=c(0,24), col=hsv(0.6,1,1), xaxt="n", yaxt="n")
axis(1,at=seq(0,365,by=60),cex.axis=1.5)
axis(2,at=seq(0,24,by=2),cex.axis=1.5)

points(x=climate$meanwinter+182,y=climate$dl,cex=0.1,col=hsv(0.6,1-0.5*(climate$lat-min(climate$lat))/(max(climate$lat)-min(climate$lat)),1))#"darkgray"

lines(daylength(20,1:365),lwd=3,col=hsv(0.6,0.9,1))
lines(daylength(40,1:365),lwd=3,col=hsv(0.6,0.8,1))
lines(daylength(50,1:365),lwd=3,col=hsv(0.6,0.7,1))
lines(daylength(60,1:365),lwd=3,col=hsv(0.6,0.6,1))
lines(daylength(70,1:365),lwd=3,col=hsv(0.6,0.5,1))
points(x=rep(180,5),y=daylength(c(20,40,50,60,70),180),bg=1,pch=21)
dev.off()
climate<-restore
```
The optimal response is 0.81 h /5 degrees latitude. the curve is exponential though



### Critical day length and latitude  

Danilevsky quotes rates of 1-1.5 hours per 5°N. Let's see if that holds for the data in this meta-analysis.

#### the full model  
```{r degN_full}
degN_full<-lme(e ~ degN, random =~ 1|order/genus/spec/ID, data=slopes, weights=~npoints, method="REML")

#level species explains 0 variance. This is because there are very few replicates on that level. To show the problem, same model in metafor:
metaf<-rma.mv(yi = e ~ degN, V=1/npoints, random = ~1|order/genus/spec/ID/popid,data = slopes) #the variance structure  is not correct (should be proportional to unknown constant) but it demonstrates the problem
profile(metaf,sigma2=3)

```

Species explains nothing because in most cases each species is replicated once (one study per species). Only 5 species occur multiple (2-3) times, usually in studies from the same authors (except O.sauteri and 1 T.urticae). To complicate things, 2 studies have 2/4 species. The low rpelication explains why the loglikelihood profile for same model in metafor is flat at the species level. It is probably best to remove ID or species from the random structure.


#### results  

_the models_   
```{r degN_models}
#model without species
degN_red<-lme(e ~ degN, random =~ 1|order/genus/ID, data=slopes, weights=~npoints, method="REML")
#model without study
degN_red2<-lme(e ~ degN, random =~ 1|order/genus/spec, data=slopes, weights=~npoints, method="REML")
#null model (with species as random)
nullme<-lme(e ~ 1, random =~ 1|order/genus/spec, data=slopes, weights=~npoints, method="REML")

summary(degN_red2)
sdevs<-c(1.0386240, 0.7267113, 0.2304249, 0.3656163)

#for comparison:
metafred<- rma.mv(yi = e ~ degN, V=1/npoints, random = ~1|order/genus/spec/popid,data = slopes)
metanull<-rma.mv(yi = e ~ 1, V=1/npoints, random = ~1|order/genus/spec/popid,data = slopes)
#summary(metafred)
#coefs are the same which is a good sign.
sdevs/sum(sdevs)
# 0.43983837 0.30774902 0.09758075 0.15483185
metafred$sigma2/sum(metafred$sigma2)
# 0.54716464 0.26793208 0.01841289 0.16649038
#random deviations are slightly larger but similar to sigma of metafor model; ratios are also similar

#all as ML fits
degN_red2.ml<-lme(e ~ degN, random =~ 1|order/genus/spec, data=slopes, weights=~npoints, method="ML")
nullme.ml<-lme(e ~ 1, random =~ 1|order/genus/spec, data=slopes, weights=~npoints, method="ML")
metafred.ml<- rma.mv(yi = e ~ degN, V=1/npoints, random = ~1|order/genus/spec/popid,data = slopes, method="ML")
metanull.ml<-rma.mv(yi = e ~ 1, V=1/npoints, random = ~1|order/genus/spec/popid,data = slopes, method="ML")

n<-table(slopes$order)
names(n)<- paste(names(n)," (", n, ")", sep = "") #will be used for plotting later, better laod it together with the model so it wont get lost
```

The following chunk calculates summary statistics, R² and statistical significance of the main effect.

_summary statistics_    
```{r degN_sumstat}
#summary statistics
quantile(slopes$degN)
#     0%      25%      50%      75%     100% 
#25.22806 36.08056 41.15000 51.84167 67.10000 
mean(slopes$degN) #44.42637

weighted.mean(slopes$e,slopes$npoints)# 14.00758
x<-daylength(44.42637,1:360)
which(x<14.05&x>13.95) #day 229 at 44.43 °N

#estimate +se
summary(degN_red2)$tTable
 #0.207123 0.0079068
#=62.13705 +- .372037 min

#contribution of random levels to overall variance
sdevs/sum(sdevs) #0.43983837 0.30774902 0.09758075 0.15483185
#can be used as replacement for I². Cant use I², because it calculates sample variance relative to overall variance. It makes little sense to compare sample size variation to overall variance
```

_R square_  
The most frequently used approach is the approach by Nakagawa, which compares heterogeneity with effects to heterogeneity of the null model. Other approaches calculate R² from the correlation of original ~ fitted values. R² can include the random terms (conditional R²) or ignore them (marginal R²). 

```{r degN_R}
#nakagawas R²
r.squaredGLMM(degN_red2) #0.79, 0.98
#marginal and conditional = without and with random effects

#simpler method for comparison:
#marginal (the random terms need to be ignored which boils down to lm):
fixedmod<-lm(slopes$e~slopes$degN,weights= slopes$npoints)
summary(lm(slopes$e~fitted(fixedmod)))$adj.r.squared #0.76
#conditional
summary(lm(slopes$e~fitted(degN_red2)))$adj.r.squared#0.90

#for comparison: metafor package (marginal only)
summary(lm(metafred$yi~fitted(metafred), weights = 1/metafred$vi))$adj.r.squared #0.73

```


_significance: LRT tests_  
```{r degN_sig}
anova(degN_red2.ml,nullme.ml) #LRT ratio = 177.8717, p<0.001
anova(metafred.ml,metanull.ml) #LRT ratio = 176.0836, p<0.001
```

#### plot  

```{r degN_plot}
svg("CDL_lat.svg",width=10,pointsize=12)
par(mar = c(5,5,0,0)+0.1)

plot(x=slopes$degN, y=slopes$e, pch=21, cex=2*slopes$npoints/10, col=1, bg=slopes$col, main = "", xlab = "Latitude (°N)", ylab = "Critical photoperiod (h)",bty="n", xaxt="n", cex.axis = 1.5, cex.lab=1.5)
legend("topleft",legend=names(n)[8:1], col=rep(1,8), pt.bg=hsv((7:0)/8,1,1), pch=21, bty="n", ncol=1,cex=1.5)
coffs <-  summary(degN_red2)$tTable[,1]
lines(x= range(slopes$degN),y = coffs[1]+coffs[2]*range(slopes$degN),lwd=3,lty=2)


axis(1,at=c(0,20,30,40,50,60,70,80),cex.axis=1.5, cex.lab = 1.5)

for(i in c(2,6,8)){
  sub<-slopes[slopes$order==unique(slopes$order)[i],]
  sinord<-lme(e ~ degN, random =~ 1|genus/spec, data=sub, weights=~npoints,   method="REML")
  coffs <-  summary(sinord)$tTable[,1]
  lines(x= range(sub$degN),y = coffs[1]+coffs[2]*range(sub$degN), lwd= 1+round(5* table(slopes$order)[i]/max(table(slopes$order))), col=sub$col[1])
  print(sub$order[1])
  print (coffs[2]*5*60)
}
points(x=slopes$degN ,y=slopes$e, pch=21, col=1, bg=slopes$col, cex=2*slopes$npoints/10)
dev.off()
#slope estimates: 
#Diptera: 64.2182  min
#Lepidoptera 69.09675 min
#mites: 49.96711 min
```

The estimate of 1 h per 5° N is not too bad, overall diapause becomes 49 min earlier per 5°.




## combining empirical data and climate

Empirical studies were not necessarily done close to a climate station. To estimate climate at a given study location, I take the average of the 5 closest stations, weighted by euclidian distance. 

```{r combine}
slopes$meanwinter<-NA
slopes$sd_winter<-NA
slopes$p<-NA
slopes$nyears<-NA
slopes$beta<-NA 

for ( i in 1:nrow(slopes)){
  #reduce to +-5 °
  sub<-climate[between(climate$lat,slopes[i,"degN"]-5,slopes[i,"degN"]+5)& between(climate$lon,slopes[i,"degE"]-5,slopes[i,"degE"]+5),]
  
  sub$diffN<-sub$lat-slopes[i,"degN"] #calculate distance in latitude
  sub$diffE<-sub$lon-slopes[i,"degE"] #same for longitude
  sub$diff<-sqrt(sub$diffN^2+sub$diffE^2) #euclidian distance

  sub<-arrange(sub,diff)[1:5,] #sort and take 5 lowest values
  

  
  slopes$meanwinter[i]<-weighted.mean(sub$meanwinter,1/sub$diff)
  slopes$sd_winter[i]<-weighted.mean(sub$sd_winter,1/sub$diff)
  slopes$p[i]<-weighted.mean(sub$p,1/sub$diff)
  slopes$nyears[i]<-weighted.mean(sub$nyears,1/sub$diff)
  slopes$beta[i]<-weighted.mean(sub$beta,1/sub$diff)

}

slopes<-slopes[!is.na(slopes$meanwinter),]
```

## correlation critical day ~ w_on * p
__calculate critical julian day__  
```{r critical_day}
slopes$cd<-NA
for ( i in 1:nrow(slopes)){
  x<-daylength(slopes[i,12],180:360)
  slopes$cd[i]<-which.min(abs(slopes[i,27]-x))+179
}
slopes$meanwinter<-slopes$meanwinter+182
```

__ the models__  
```{r cd_models}
cd_full.ml<-lme(cd ~ meanwinter * sd_winter, random =~ 1|order/genus/spec, data=slopes, weights=~npoints, method="ML")
cd_2.ml<-   lme(cd ~ meanwinter + sd_winter, random =~ 1|order/genus/spec, data=slopes, weights=~npoints, method="ML")
cd_3.ml<-   lme(cd ~ meanwinter              , random =~ 1|order/genus/spec, data=slopes, weights=~npoints, method="ML")
cd_4.ml<-   lme(cd ~              sd_winter, random =~ 1|order/genus/spec, data=slopes, weights=~npoints, method="ML")
cd_null.ml<-lme(cd ~1                      , random =~ 1|order/genus/spec, data=slopes, weights=~npoints, method="ML")

anova(cd_full.ml,cd_2.ml)
AIC(cd_full.ml)-AIC(cd_2.ml)
anova(cd_2.ml,cd_3.ml)
AIC(cd_2.ml)-AIC(cd_3.ml)
anova(cd_2.ml, cd_4.ml)
AIC(cd_2.ml)-AIC(cd_4.ml)


cd_full<-   lme(cd ~ meanwinter + sd_winter, random =~ 1|order/genus/spec, data=slopes, weights=~npoints, method="REML")
cd_m<-   lme(cd ~ meanwinter              , random =~ 1|order/genus/spec, data=slopes, weights=~npoints, method="REML")
cd_sd<-   lme(cd ~              sd_winter, random =~ 1|order/genus/spec, data=slopes, weights=~npoints, method="REML")

#summary(cd_full)
sdevs<-c(16.16497, 20.62354, 7.311302, 7.474556)
sdevs/(sum(sdevs))
```

#### results
```{r cd_results}
#summary statistics
quantile(slopes$meanwinter)
#  0%       25%       50%       75%      100% 
#218.3225 277.9196 300.6706 320.4777 385.6553 
mean(slopes$meanwinter) #297.1511
weighted.mean(slopes$cd,slopes$npoints)# 239.2938

#estimate +se
summary(cd_m)$tTable
 #m : 0.7048972 +- 0.05925753
summary(cd_sd)$tTable
# sd: 1.078942 +- 0.4745538

#nakagawas R²
r.squaredGLMM(cd_full) #0.4438754 0.9609653
r.squaredGLMM(cd_m) #0.4530274 0.9595231
r.squaredGLMM(cd_sd) #0.02544708 0.8896726
#marginal and conditional = without and with random effects
```

#### plot cd ~ meanwinter
```{r cdwon}
svg("cd_won.svg",width=10,pointsize=12)
par(mar = c(5,5,0,0)+0.1)

plot(x=slopes$meanwinter, y=slopes$cd, pch=21, cex=2*slopes$npoints/10, col=1, bg=slopes$col, main = "", xlab = "Julian day of winter onset", ylab = "Critical day",bty="n", xaxt="n", cex.axis = 1.5, cex.lab=1.5)
legend("topleft",legend=names(n)[8:1], col=rep(1,8), pt.bg=hsv((7:0)/8,1,1), pch=21, bty="n", ncol=1,cex=1.5)
coffs <-  summary(cd_m)$tTable[,1]
lines(x= range(slopes$meanwinter),y = coffs[1]+coffs[2]*range(slopes$meanwinter),lwd=3,lty=2,xpd=T)

axis(1,at=c(210,240,270,300,330,365,395),labels = c(210,240,270,300,330,0,30),cex.axis=1.5, cex.lab = 1.5)

for(i in c(2,6,8)){
  sub<-slopes[slopes$order==unique(slopes$order)[i],]
  sub<-droplevels(sub)
  sinord<-lme(cd ~ meanwinter, random =~ 1|genus/spec, data=sub, weights=~npoints,   method="REML")
  coffs <-  summary(sinord)$tTable[,1]
  lines(x= range(sub$meanwinter),y = coffs[1]+coffs[2]*range(sub$meanwinter), lwd= 1+round(5* table(slopes$order)[i]/max(table(slopes$order))), col=sub$col[1])
  print(sub$order[1])
  print (coffs[2])
}
points(y=slopes$cd ,x=slopes$meanwinter, pch=21, col=1, bg=slopes$col, cex=2*slopes$npoints/10)
dev.off()
#slope estimates
#diptera: 0.5287144 
#lepidoptera: 1.34405 
#mites: 1.056231
```

#### plot cd ~ sd_winter
```{r cdsd}
svg("cd_sd.svg",width=10,pointsize=12)
par(mar = c(5,5,0,0)+0.1)

plot(x=slopes$sd_winter, y=slopes$cd, pch=21, cex=2*slopes$npoints/10, col=1, bg=slopes$col, main = "", xlab = "Winter predictability", ylab = "Critical day",bty="n", xaxt="n", cex.axis = 1.5, cex.lab=1.5)
legend("topleft",legend=names(n)[8:1], col=rep(1,8), pt.bg=hsv((7:0)/8,1,1), pch=21, bty="n", ncol=1,cex=1.5)
coffs <-  summary(cd_sd)$tTable[,1]
lines(x= range(slopes$sd_winter),y = coffs[1]+coffs[2]*range(slopes$sd_winter),lwd=3,lty=2,xpd=T)

axis(1,at=c(5,10,15,20,25),cex.axis=1.5, cex.lab = 1.5)

for(i in c(2,6,8)){
  sub<-slopes[slopes$order==unique(slopes$order)[i],]
  sub<-droplevels(sub)
  sinord<-lme(cd ~ sd_winter, random =~ 1|genus/spec, data=sub, weights=~npoints,   method="REML")
  coffs <-  summary(sinord)$tTable[,1]
  lines(x= range(sub$sd_winter),y = coffs[1]+coffs[2]*range(sub$sd_winter), lwd= 1+round(5* table(slopes$order)[i]/max(table(slopes$order))), col=sub$col[1])
  print(sub$order[1])
  print (coffs[2])
}
points(x=slopes$cd ,y=slopes$sd_winter, pch=21, col=1, bg=slopes$col, cex=2*slopes$npoints/10)
dev.off()
```


## within vs between treat variance  
making a plot of plasticity - bet-hedging - non-adaptive variation and showing where the data points lie on this plot

```{r varwithbet}
svg("parspace.svg",width=10,pointsize=12)
par(mar = c(5,5,0,0)+0.1)

x<-(slopes$sd_winter-min(slopes$sd_winter))/(max(slopes$sd_winter)-min(slopes$sd_winter)) #a vector for the colours, ranges from 0(lowest winter sd, highest predictability) to 1 (lowest predictability)
#hsv(1,1-x,1) will be red for high predictability, white for low predictability
plot(y=slopes$within,x=slopes$between,pch=21,col=NA,bg=hsv(1,1-x,1),xlab = "Variance between environments",ylab="Variance within environments",ylim = c(0,250),xaxt="n",yaxt="n",cex.lab=1.5,bty="n") 
axis(1,at=c(0,0.000125,0.00025), labels=c("low","medium","high"), cex.axis=1.5)
axis(2, at = c(0,125,250), labels=c("low","medium","high"), cex.axis=1.5)
logcurve<-function(x,b,c,d,e){(d-c)/(1+exp(-b*(x-e)))+c}
x<-seq(12-4, 12+4, length.out =1000)

w<-rep(NA,100)
bet<-rep(NA,100)
for ( i in 0:999){
 y_a<-logcurve(x,b=i/20,c= 0,d=1,e=12)
    w[i]<-sum(y_a*(1-y_a))
    bet[i]<- (sd(y_a)/(sqrt(length(y_a))))^2
}
segments(x0 = bet[1:999],y0 = w[1:999],x1 = bet[2:1000],y1 = w[2:1000],lwd=3,col="grey") #this line shows varying slopes for c,d = 0,1; it is also the outer parameter space

for ( i in 0:999){
 y_a<-logcurve(x,b=100,c= 0,d=i/1000,e=12)
    w[i]<-sum(y_a*(1-y_a))
    bet[i]<- (sd(y_a)/(sqrt(length(y_a))))^2
}
segments(x0 = bet[1:999],y0 = w[1:999],x1 = bet[2:1000],y1 = w[2:1000],lwd=3,col="grey") # this line shows varing d for max slope


for ( i in 0:999){
 y_a<-logcurve(x,b=100,c= 0.5-(5*i/1000),d=0.5+(5*i/1000),e=12)
    w[i]<-sum(y_a*(1-y_a))
    bet[i]<- (sd(y_a)/(sqrt(length(y_a))))^2
}
segments(x0 = bet[1:999],y0 = w[1:999],x1 = bet[2:1000],y1 = w[2:1000],lwd=3,col="grey") # this line shows varing range for max slope

x<-(slopes$sd_winter-min(slopes$sd_winter))/(max(slopes$sd_winter)-min(slopes$sd_winter))
points(y=slopes$within,x=slopes$between,pch=21,col=NA,bg=hsv(1,1-x,1))
#points(y=slopes$within,x=slopes$between,pch=21,col=NA,bg=hsv(1,1-x,1))
#points(points(w_a~bet_a,col=4,pch=22,bg=4))
#text(x=bet_a+0.00001,y= w_a, "C")
#points(points(w_b~bet_b,col=4,pch=22,bg=4))
#text(x=bet_b+0.00001,y= w_b, "B")
#points(points(w_c~bet_c,col=4,pch=22,bg=4))
#text(x=bet_c+0.00001,y= w_c, "D")
#points(points(w_d~bet_d,col=4,pch=22,bg=4))
#text(x=bet_d-0.00001,y= w_d, "A")
dev.off()
```
drawing curves for four corners of above plot (to check whether everything is correct)

```{r explain}
x<-seq(12-4, 12+4, length.out =1000)
y_a<-logcurve(x,b=0,c=0.5,d=0.5,e=12)
y_b<-logcurve(x,b=100,c=0.1,d=0.9,e=12)
y_c<-logcurve(x,b=0,c=0,d=0.1,e=12)
y_d<-logcurve(x,b=100,c=0,d=1,e=12)

w_a<-sum(y_a*(1-y_a))
w_b<-sum(y_b*(1-y_b))
w_c<-sum(y_c*(1-y_c))
w_d<-sum(y_d*(1-y_d))

bet_a <- (sd(y_a)/(sqrt(length(y_a))))^2
bet_b <- (sd(y_b)/(sqrt(length(y_b))))^2
bet_c <- (sd(y_c)/(sqrt(length(y_c))))^2
bet_d <- (sd(y_d)/(sqrt(length(y_d))))^2



par(mfrow=c(2,2),mar=c(2,2,2,2))
plot(y_a~x,type="l",ylim=c(0,1),lwd=2)
text(13,0.1,paste("within:",round(w_a,2)))
text(13,0,paste("between:",round(bet_a,5)))
plot(y_b~x,type="l",ylim=c(0,1),lwd=2)
text(13,0.1,paste("within:",round(w_b,2)))
text(13,0,paste("between:",round(bet_b,5)))
plot(y_c~x,type="l",ylim=c(0,1),lwd=2)
text(13,0.1,paste("within:",round(w_c,2)))
text(13,0,paste("between:",round(bet_c,5)))
plot(y_d~x,type="l",ylim=c(0,1),lwd=2)
text(13,0.1,paste("within:",round(w_d,2)))
text(13,0,paste("between:",round(bet_d,5)))

```

## plasticity vs predictability
```{r plastic_mod}
slopes$between<-scale(slopes$between)
bet_full<-lme(between ~ sd_winter, random =~ 1|order/genus/spec, data=slopes, weights=~npoints, method="REML")

#metaf<-rma.mv(yi = between ~ sd_winter, V=0.06, random = ~1|order/genus/spec/popid,data = slopes) 
#profile(metaf,sigma2=1)#
#profile(metaf,sigma2=2)
#profile(metaf,sigma2=3)
#profile(metaf,sigma2=4)
#model looks good

bet_full.ml<-lme(between ~ sd_winter, random =~ 1|order/genus/spec, data=slopes, weights=~npoints, method="ML")
bet_null.ml<-lme(between ~ 1, random =~ 1|order/genus/spec, data=slopes, weights=~npoints, method="ML")
anova(bet_full.ml,bet_null.ml)#lrt ratio 12.57719, p = 4e-04

#summary(cd_full)
sdevs<-c(0.4167283, 0.522575, 0.4340173, 0.3766424)
sdevs/(sum(sdevs))#0.2381355 0.2986206 0.2480151 0.2152288

summary(bet_full)$tTable
 #-0.06229402 +- 0.01749654

#nakagawas R²
r.squaredGLMM(bet_full) #0.08688312 0.8332844
```


```{r plot_plast}
svg("betw_sd.svg",width=10,pointsize=12)
par(mar = c(5,5,0,0)+0.1)

plot(x=slopes$sd_winter, y=slopes$between, pch=21, cex=2*slopes$npoints/10, col=1, bg=slopes$col, main = "", xlab = "Winter unpredictability", ylab = "Plasticity",bty="n", xaxt="n", cex.axis = 1.5, cex.lab=1.5)
legend("bottomleft",legend=names(n)[8:1], col=rep(1,8), pt.bg=hsv((7:0)/8,1,1), pch=21, bty="n", ncol=1,cex=1.5)
coffs <-  summary(bet_full)$tTable[,1]
lines(x= range(slopes$sd_winter),y = coffs[1]+coffs[2]*range(slopes$sd_winter),lwd=3,lty=2,xpd=T)

axis(1,at=c(5,10,15,20,25),cex.axis=1.5, cex.lab = 1.5)

for(i in c(2,6,8)){
  sub<-slopes[slopes$order==unique(slopes$order)[i],]
  sub<-droplevels(sub)
  sinord<-lme(between ~ sd_winter, random =~ 1|genus/spec, data=sub, weights=~npoints,   method="REML")
  coffs <-  summary(sinord)$tTable[,1]
  lines(x= range(sub$sd_winter),y = coffs[1]+coffs[2]*range(sub$sd_winter), lwd= 1+round(5* table(slopes$order)[i]/max(table(slopes$order))), col=sub$col[1])
  print(sub$order[1])
  print (coffs[2])
}
points(x=slopes$cd ,y=slopes$sd_winter, pch=21, col=1, bg=slopes$col, cex=2*slopes$npoints/10)
dev.off()
#diptera: -0.07337133 
#lepidoptera: -0.008580579 
#mites: 0.008729344 
```

```{r}
slopes$between<-scale(slopes$between)
slopes$within<-scale(slopes$within)
slopes$p<-scale(slopes$p)

plot(slopes$within~slopes$between)
x<-slopes$p- min(slopes$p)
x<-x/max(x)
points(slopes$within~slopes$between,pch=21,bg=hsv(1,1-x,1))


bet_full<-lme(within ~ between*p, random =~ 1|order/genus/spec, data=slopes, weights=~npoints, method="REML")
bet_red<-lme(within ~ between+p, random =~ 1|order/genus/spec, data=slopes, weights=~npoints, method="REML")
#nakagawas R²
r.squaredGLMM(bet_full) #0.8413381 0.9755626
r.squaredGLMM(bet_red) # 0.79405 0.9671184
```

```{r}
svg("parspace2.svg",width=10,pointsize=12)
par(mar = c(5,5,0,0)+0.1)
x<-slopes$p- min(slopes$p)
x<-x/max(x)
plot(y=slopes$within,x=slopes$between,pch=21,col=NA,bg=hsv(1,1-x,1),xlab = "Variance between environments",ylab="Variance within environments",xaxt="n",yaxt="n",cex.lab=1.5,bty="n") 
axis(1,at=c(min(slopes$between),max(slopes$between)), labels=c("low","high"), cex.axis=1.5)
axis(2, at = c(min(slopes$within),max(slopes$within)), labels=c("low","high"), cex.axis=1.5)
logcurve<-function(x,b,c,d,e){(d-c)/(1+exp(-b*(x-e)))+c}
x<-seq(12-4, 12+4, length.out =1000)

dev.off()
```
```{r beta}

```

